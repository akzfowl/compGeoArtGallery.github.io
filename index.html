<html>
	<head>
		<title>Computational Geometry Project (CSCI 716): The Art Gallery Problem</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			table, th, td {
				border: 1px solid black;
			}
			img {
				max-width: 100%;
				max-height: 100%;
				height: auto; 
			}
		</style>
	</head>
	<body onload="init();">
		<br>
		<section>
			<H1 align="center"><b>Computational Geometry (CSCI 716) Project: The Art Gallery Problem</b></H1>
			<br>
			<H3 align="center"><a href="#proposal">1. Project Proposal</a></H3>
			<H3 align="center"><a href="#preliminaryResults">2. Preliminary Results</a></H3>
			<H3 align="center"><a href="#preliminaryResults2">3. Preliminary Results 2.0</a></H3>
			<H3 align="center"><a href="#finalReport">4. Final Report</a></H3>
			<H3 align="center"><a href="#visibilityApp">5. Visibility Application</a></H3>
		</section>
		<br>
		<br>
		<section>
			<a name="proposal" />
			<H2 align="center">Project Proposal</H2>
		</section>
		<br>
		<section>
			<H2>Project Title:</H2>
			<H3>The Art Gallery Problem</H3>
			<hr>
		</section>
		<section>
			<H2>Team Members:</H2>
			<H4>Akshay Sharma (acs1246)</H4>
			<H4>Darshan Kavathe (dck1135)</H4>
			<hr>
		</section>
		<section>
			<H2>Motivation:</H2>
			<p>
			The art gallery problem is a well known one which has applications in wide and interesting areas. Although it is framed as a security problem where guards vigilantly protect an art gallery, it can also be framed as an illumination problem. This transforms it into providing optimal illumination within a closed building while minimizing the number of lights being used. This issue of visibility can be used within games for level design as well - just imagine a group of non-player characters patrolling an area while the player himself has to stealthily move around or even attack them. Interestingly enough, the art gallery problem is almost directly applicable to tower defence style games where the player needs to place objects like turrets at various positions within a structure to secure it against adversaries that gradually increase in strength and speed. 
			<br><br>
			Along with the above use cases, the art gallery problem also seems applicable to areas such as the design of buildings and vehicles, route planning and even circuit design. For these reasons, and because it presents such an interesting setting along with many intriguing variations, we have decided to look at this problem and hope to gain some insight into how computer scientists over the ages have chosen to tackle it, and perhaps contribute something as well.
			</p>
			<hr>
		</section>
		<section>
			<H2>Description:</H2>
			<p>The art gallery problem is also popularly called the museum problem. In computational geometry literature, it is also referred to as the Vertex-Pi Floodlights problem. The problem is named after the real-world problem of guarding an art gallery or a museum with as few guards as possible in such a way that the guards are collectively able to keep all parts of the museum in sight at all times. In computational geometry, the gallery is typically represented using a 'simple polygon' (a flat shape created by straight, non-intersecting sides that form a closed path in a pair-wise fashion). A set of points is said to 'guard' a portion of the polygon if, for each point 'a' inside the polygon, another point 'b' exists such that the line joining 'a' and 'b' does not have any portion outside the polygon.
			<br><br>
			As part of our project, we plan to survey the body of work surrounding this well-studied problem, arrive at the best methods available, try out our own methods of solving the problem and also look at known variations of the problem involving moving guards and polygons of varying shapes.
			<br><br>
			Ideally, we would also like to have a few implementations of the problem that can be used to run simulations of it along with showcasing possible solutions in a web application.</p>
			<hr>
		</section>
		<section>
			<H2>References:</H2>
			<p>[1]<i> Jacob E. Goodman, Joseph O'Rourke, and Csaba D. Tóth.  </i><a href="https://www.csun.edu/~ctoth/Handbook/HDCG3.html">Handbook of Discrete and Computational Geometry, Third Edition,CRC Press LLC.</a></p>
			<p>[2]<i> Joseph O'Rourke.  </i><a href="http://cs.smith.edu/~jorourke/books/ArtGalleryTheorems/art.html">Art Gallery Theorems and Algorithms.</a></p>
			<p>[3]<i> Francisc Bungiu, Michael Hemmer, John Hershberger, Kan Huang, Alexander Kröller. </i><a href="https://arxiv.org/abs/1403.3905">Efficient Computation of Visibility Polygons.</a></p>
			<p>[4]<i> Édouard Bonnet, Tillmann Miltzow. </i><a href="https://arxiv.org/abs/1607.05527">An Approximation Algorithm for the Art Gallery Problem.</a></p>
			<p>[5]<i> Jorge Urrutia. </i><a href="https://www.cs.duke.edu/courses/spring07/cps296.2/papers/Art-Galleries.pdf">Art Gallery and Illumination Problems.</a></p>
			<hr>
		</section>	
		<section>
			<H2>Timeline:</H2>
			<p>09/29 - 10/04 : Go through papers and other available materials related to the problem and its variations. Try to highlight approaches that may be of particular use.</p>

			<p>10/05 - 10/31 : Try our own approaches to the problem and catalogue possible shortcomings with each approach. Start with implementing small versions of the problem and dive deeper into the methods used.</p>

			<p>11/01 - 11/19 : Create the actual applications along with visualizations.</p>

			<p>11/20 - 11/31 : Work on the final report and presentation.</p>
			<hr>
		</section>
		<section>
			<H2>Division of roles:</H2>

			<p>Akshay: Investigate triangulation and graph colouring as possible solutions. Try Threejs for visualizing the problems. Look at concave variations.</p>

			<p>Darshan: Investigate convex partitioning and linear programming as possible solutions. Look at the mobile guards and exterior viewing scenario. </p>
		</section>
		<br>
		<br>
		<hr>
		<hr>
		<hr>
		<br>
		<br>
		<section>
			<a name="preliminaryResults" />
			<H2 align="center">Pre-liminary Results - Triangulation and Colouring</H2>
		</section>
		<br>
		<section>
			<H2 align="center">Program to determine vertex guard positions using triangulation and 3-colouring of the given polygon</H2>
			<br>
			<p>
				As part of a more naive approach to solve the problem for regular polygons, we implemented a program to perform triangulation and 3-colouring of a given polygon. <br>
				It displays the output polygon with diagonals drawn, colouring of the vertices and the positions of the vertex guards.
			</p>
			<p>
				Few things to point out:<br>
				- The polygons are shown in red.<br>
				- Diagonals caused for triangulation are shown in green.<br>
				- The vertices are shown in 3 different colours - yellow, dark blue and cyan.<br>
				- The vertex guard positions are superimposed as Xs on the vertices corresponding to the found minimum vertex colour.<br>
			</p>
			<p>
				Some screen shots of the outputs generated by the program are displayed below along with brief descriptions:
			</p>
			<br>
			1) This is an orthogonal polygon with axis parallel edges.<br>
			 More complicated orthogonal figures might require quadrilateralization instead of triangulation, but here it seems to do the job. <br><br>

			Number of vertex guards found: 2.
			<p align="center"> 
				
				<img src="images/Output1.png" alt="Image 1">
			</p>
			<br>
			<br>
			2) This is a more complicated orthogonal polygon with axis parallel edges. It is clear from looking at it that the triagulations produced are becoming more complicated now. <br><br>

			Number of vertex guards found: 12.
			<p align="center">
				<img src="images/Output2.png" alt="Image 2">
			</p>
			<br>
			<br>
			3) This is a polygon with a mixture of orthogonal and normal edges. <br><br>

			Number of vertex guards found: 4.
			<p align="center">
				<img src="images/Output3.png" alt="Image 3">
			</p>
			<br>
			<br>
			4) This is a more complicated polygon with no orthogonal edges. <br><br>

			Number of vertex guards found: 5.
			<p align="center">
				<img src="images/Output4.png" alt="Image 4">
			</p>
			<br>
			<br>
			5) This is a regular pentagon. <br><br>

			Number of vertex guards found: 1.
			<p align="center">
				<img src="images/Output5.png" alt="Image 5">
			</p>
			<br>
			<br>
			6) This is a septagon. <br><br>

			Number of vertex guards found: 2.<br><br>
			As can be clearly seen, 1 guard should have sufficed here. An art gallery shaped in this manner, would not required 2 guards. <br>
			This example shows that 3-colouring on its own can never sufficiently guarantee a good solution to the problem. Additional visibility checks are required.

			<p align="center">
				<img src="images/Output6.png" alt="Image 6">
			</p>
			<br>
			<br>
			7) This is a popular example to test Art Gallery Solutions on.  <br><br>

			Number of vertex guards found: 4.
			<p align="center">
				<img src="images/Output7.png" alt="Image 7">
			</p>
		</section>
		<section>
			<p>
				The program was written in Python 3 and all the plots shown here were obtained using the popular Matplotlib library.
			</p>
		</section>
		<section>
			<H2>References</H2>
			<p>[1] <i>Wikipedia - Graph Colouring.</i> <a href="https://en.wikipedia.org/wiki/Graph_coloring">Graph Colouring</a></p>
			<p>[2] <i>University of Manchester - Discrete Maths.</i> <a href="http://www.maths.manchester.ac.uk/~mrm/Teaching/DiscreteMaths/LectureNotes/GraphColouring">Graph Colouring with the Greedy Method</a></p>
			<p>[3] <i>UCSB - Computational Geometry.</i> <a href="https://www.cs.ucsb.edu/~suri/cs235/Triangulation.pdf">Polygon Triangulation and Colouring</a></p>
		</section>
		<br>
		<br>
		<hr>
		<hr>
		<hr>
		<br>
		<br>
		<section>
			<a name="preliminaryResults2" />
			<H2 align="center">Pre-liminary Results - Guard Visibility Polygons</H2>
		</section>
		<br />
		<section>
			<H2 align="center">Program to determine the visibility polygon for a guard using ray casting</H2>
			<br>
			<p>
				A very important portion of the AGP is the question of the visibility of each guard, i.e., the area inside the polygon actually visible to the guard.
			</p>
			<p>
				In our program, we have assumed that the guard has infinite vision in all directions as long as there are no obstructions present.<br>
				Our approach is to cast rays to all the vertices of the polygon that make up the art gallery in the problem and determine the visibility polygon
				by combining the results. Any rays met with obstruction enroute to a target vertex, stop on the obstacle itself. Therefore, our solution
				has no problems dealing with so-called 'holes' in the polygons. 
			</p>
			<p>
				In order to produce a contrast between the guarded and unguarded spaces, we have used a grey colour to indicate unguarded external spaces,
				a black colour to indicate unguarded art gallery spaces and a bright yellow to denote a reassuring and secure space (both internal and external).
			</p>
			<p>
				We have created a bounding box around all the polygons to constrain vision of the guards.<br>
				We intend to showcase this as an interactive application with the user able to drag around the 'guard' and easily picture visibility.<br>
				Shown below is a selection of outputs from this program:
			</p>
			<br>
			<br>
			1) Crown -  A popular for art gallery problems. Visibility can vary drastically with position.
			<p align="center">
				<img src="images/Visibility1.PNG" alt="Visibility 1">
				<br>
				<img src="images/Visibility2.PNG" alt="Visibility 2">
				<br>
				<img src="images/Visibility3.PNG" alt="Visibility 3">
				<br>
				<img src="images/Visibility4.PNG" alt="Visibility 4">
			</p>
			<br>
			<br>
			2) Long, dark corridors - A polygon with 100 vertices.
			<p align="center">
				<img src="images/Visibility5.PNG" alt="Visibility 5">
				<br>
				<img src="images/Visibility6.PNG" alt="Visibility 6">
				<br>
				<img src="images/Visibility7.PNG" alt="Visibility 7">
			</p>
			<br>
			<br>
			3) Several art galleries - An area with several art galleries, some already shown above, others newly added.
			<p align="center">
				<img src="images/Visibility8.PNG" alt="Visibility 8">
				<br>
				<br>
				<img src="images/Visibility9.PNG" alt="Visibility 9">
				<br>
				<br>
				<img src="images/Visibility10.PNG" alt="Visibility 10">
				<br>
				<br>
				<img src="images/Visibility11.PNG" alt="Visibility 11">
			</p>
		</section>
		<section>
			<p>
				The program was written in Javascript and HTML5 using Canvas.
			</p>
		</section>
		<section>
			<H2>References</H2>
			<p>[1] <i>Wikipedia - Visibility Polygon.</i> <a href="https://en.wikipedia.org/wiki/Visibility_polygon">Visibility Polygon</a></p>
			<p>[2] <i> Joseph O'Rourke.  </i><a href="http://cs.smith.edu/~jorourke/books/ArtGalleryTheorems/art.html">Art Gallery Theorems and Algorithms.</a></p>
			<p>[3] <i>Red Blog Games.</i> <a href="https://www.redblobgames.com/articles/visibility/">2D Visibility</a></p>
		</section>
		<br>
		<br>
		<hr>
		<hr>
		<hr>
		<br>
		<br>
		<section>
			<a name="finalReport" />
			<H2 align="center">The Art Gallery Problem</H2>
			<H4 align="center">Akshay Sharma, Darshan Kavathe</H4>
			<H4 align="center">(<a href="mailto:acs1246@rit.edu">acs1246@rit.edu</a>, <a href="mailto:dck1135@rit.edu">dck1135@rit.edu</a>)</H4>
			<H4 align="center"><b>CSCI 716: Computational Geometry - Professor Reynold Bailey</b></H4>
		</section>
		<br />
		<br />
		<section>
			<H2 align="center">Problem Overview</H2>
			<p align="justify">
				The art gallery problem (also called the museum problem) is basically a visibility problem in computational geometry. It is notably included among the open problems in the field which has been attempted by several researchers and practitioners over decades. It is named after the real world problem of securing or illuminating the entire interior of an art gallery (or a museum) using the minimum possible guards (or lights/cameras). The polygons generally considered while solving the problem are simple polygons and a point is usually termed as visible from another if the line joining the two lies completely within the polygon without hitting any obstacles in its path. Our goal is to look at the research that has already been done in this field and attempt to implement some of them while at that same time modifying approaches as we may see fit.
			</p>
		</section>
		<br>
		<section>
			<H2 align="center">Background</H2>
			<p align="justify">
				The polygons usually considered part of this problem are all termed ‘simple’. Simple polygons possess the following properties: they enclose a region with a definite, measurable area, their edges meet only at the ends, no more than two edges meet at a vertex and the number of edges present always equals the number of vertices. So, the polygons considered are not necessarily monotone in nature, they may contain inner walls and potentially even obstructions within them commonly termed ‘holes’ in the literature. Originally, Victor Klee had posed this as an open question <i>[1]</i>.
				Visibility from a point is defined as the area inside the art gallery visible from that point i.e., we can draw a straight line from the point to any other point in that area without crossing the boundaries of polygon.
			</p>
			<p align="justify">
				There are some variations of this problem based on guard placement and type of  movement allowed:<br>
				<b>Vertex Guards:</b> Guards are placed only at the vertices of the polygon.<br>
				<b>Edge Guards:</b> Guards can move along the edges of the polygon.<br>
				<b>Point Guards:</b> Guards can be placed anywhere in the polygon.<br>
				<b>Stationary Guards:</b> Guards remain in the same position.<br>
				<b>Mobile Guards:</b> Guards can move along a path inside the polygon (usually restricted to diagonals or edges).<br>
				<b>Hidden Guards:</b> No two guards are visible to each other.<br>
				<b>Guarded Guards:</b> Every guard is visible to at least one other guard.<br>
			</p>
			<p align="justify">
				Other terms useful to know:<br>
				<b>Colouring:</b> The process of labelling the nodes of a graph using 'colours' such that no adjacent nodes are coloured the same.<br>
				<b>3-Colouring:</b> The process of colouring of graph with only 3 colours.<br>
				<b>Triangulation:</b> Decomposing a given polygon into triangles by adding daigonals.<br>
				<b>General polygon:</b> A non-orthogonal polygon.<br>
				<b>Orthogonal polygon:</b> A polygon whose edges are all aligned with pair of orthogonal coordinate axes which could possibly be vertical and horizontal. All internal angles are thus 90 degrees or 270 degrees.
			</p>
			<p align="justify">
				Victor Klee’s question pertained to stationary guards <i>[1]</i>. Chvatal answered by proving that a simple polygon needed at most n/3 guards<i>[1]</i>. Fisk then provided a proof for Chvatal’s result using triangulation and colouring<i>[1]</i>. Avis and Toussaint came up with an algorithm for positioning guards in O(n log n) time<i>[1]</i>. O’Rourke then proved that a simple polygon needed at most n/4 mobile guards<i>[1]</i>. Rourke also went on to prove that simple polygons with holes required at most n+2h/3 vertex guards<i>[1]</i>. Kahn proved that n/4 guards were sufficient for orthogonal polygons<i>[1]</i>. This was done through convex quadrilateralization followed by colouring. Aggarwal then showed that (3n+4)/16 mobile guards sufficed for orthogonal polygons<i>[1]</i>. It has been repeatedly proven that the art gallery problem is an NP hard problem by reducing it to the well known set cover problem.
			</p>
		</section>
		<br>
		<section>
			<H2 align="center">Proof of NP - Hardness</H2>
			<p align="justify">
				The set cover problem was one of the original NP complete problems among Karp’s 21 NP complete problem. It refers to the problem of finding the smallest subset of a given set that would be its equivalent. Basically, given a universal set U, and a bunch of subsets s<sub>1</sub>, s<sub>2</sub>,..., s<sub>n</sub>, the optimization version of the problem (which is proven to be NP Hard), requires us to find the most minimal combination of the subsets such that they fully ‘cover’ U or contain all the items in U. 
			</p>
			<p  align="justify">
				In the art gallery problem, there are analogues to the sets mentioned above. Given the art gallery polygon ‘P’, we first need to partition it into several convex polygons that tend to share vertices known as convex fans. This partitioning can be done by joining pairs of vertices in the polygon and then extending them in both directions till the line hits the outer boundary of the polygon. The polygon resulting from this procedure is termed an ‘Arrangement’ in the literature. Let call this arrangement ‘A’. Every polygon formed due to A is convex in nature. Each of these polygons are known as ‘cells’ in the literature. Each of these cells lies on a ‘fan’ in the polygon. Several such cells may share a fan. Given these conditions, we can reformulate the art gallery problem to have a set S consisting of the convex cells in the arrangement A and the objective is to find the set C which consists of the minimum number of vertices of P that are needed to completely cover S. This can be accomplished by choosing the number of vertices whose fans cover all the cells of A, which constitutes the set cover problem.
			</p>
			<p  align="justify">
				The figure on the left below is a popular representation of the set cover problem and the one on the right shows how an art gallery polygon P would need to be partitioned in order to arrive at the optimal solution.
			</p>
			<br>
			<p align="center">
				<img src="images/Set Cover.PNG" alt="Set Cover Illustration" hspace="150">
				<img src="images/Division into an Arrangement.PNG" alt="Partitioning Illustration">
			</p>
			<br>
			<p align="justify">
				Commonly optimization problems of this nature are solved using a method called Integer Linear Programming (ILP) which optimizes the answer at each of the iterative steps it takes. As we shall see, ILP can also be successfully applied to the art gallery problem to yield optimal solutions.
			</p>
		</section>
		<br>
		<section>
			<H2 align="center">Known Bounds and Results</H2>
			<p align="justify">
				These are some proved lower bounds on number of guards in general and orthogonal polygon.
			</p>
			<table style="width:100%;">
			  <tr>
			    <th></th>
			    <th align="center">Stationary Guards</th> 
			    <th align="center">Mobile Guards</th>
			  </tr>
			  <tr>
			    <td align="center">General</td>
			    <td align="center">n/3 (<i>Chvatal</i>)[1]</td> 
			    <td align="center">n/4 (<i>O'Rourke</i>)[1]</td>
			  </tr>
			  <tr>
			    <td align="center">Orthogonal</td>
			    <td align="center">n/4 (<i>Kahn</i>)[1]</td> 
			    <td align="center">(3n+4)/16 (<i>Aggarwal</i>)[5]</td>
			  </tr>
			</table>
			<p align="justify">
				For a simple polygon with n vertices and h holes, the upper bound is known to be (n+2h)/3 (<i>Hoffmann, Kaufmann, Kriegel 1991</i> [5]). And in general, the number of mobile guards required to cover a given gallery is only 75% of the number of stationary guards required.

				Other than these, Chazelle came up with an O(n<sup>3</sup>) dynamic algorithm for convex partitioning, using which art gallery problem can be reduced to set cover problem (known to be NP-Hard), but approximation algorithms exist.  Ghosh (2010) gave an O(n<sup>4</sup>) time approximation algorithm for the minimum vertex guard problem. There are some algorithms which use linear integer programming for approximation.
			</p>
		</section>
		<br>
		<section>
			<H2 align="center"> Our Approaches</H2>
		</section>
		<br>
		<section>
			<H3 align="center">Approach 1: Triangulation and 3-Colouring</H3>
			<p align="justify">
				True to the first approach proven and tried in the literature, we decided to implement a solution using triangulation and 3-colouring of a given polygon. Obviously we realized that this alone would never give us the optimal solution, but we thought it would be a good starting point from where further augmentations could seriously be thought about. Our solution performs triangulation of input polygons using the line sweep approach so it is divided into two parts: monotone sub-division and polygonal triangulation of the individual polygons. 
			</p>
			<p align="justify">
				Monotone sub-division is important for the algorithm to proceed because the triangulation approach assumes that it is dealing with such a polygon and this makes it much easier to do. We first check if the given polygon is already monotone by dividing it into upper and lower chains about the leftmost and rightmost vertices. We then walk along each of these chains to ensure they are always non-decreasing in nature. If this is indeed the case, we can proceed straight to the triangulation portion of the algorithm. If not, we have to perform a left to right sweep across the polygon and attempt to identify the merge and split vertices within the polygon. We add all the vertices of the polygon we encounter into a tree which is ordered by the x value of the vertex. We also maintain the sweep-line using a balanced tree that stores the edges at any point ordered by the y-coordinates. If we encounter multiple line segments emanating from a single point in the polygon, we identify the immediately previous occurring vertex as a split vertex. We use the x-coordinate to search the tree and check which is the previous vertex. We deal with it immediately by adding a diagonal to the polygon by attaching the split vertex with a previous point in the polygon below the uppermost line segment present. If there are multiple such points present in the polygon, we use the point with the highest y coordinate. Before creating this diagonal, we first make sure that the point is visible from the split vertex. A merge vertex can be identified when two line segments in the polygon intersect and yet the polygon is not over yet. In this case, we remember the merge vertex and wait to encounter the next vertex in the polygon which is visible to the merge vertex. When such a vertex is encountered, we add a diagonal attaching the two. These are two types of vertices we can encounter to enable subdivision. They may occur in varying configurations but handling them as mentioned above will ensure several monotone polygons at the end. Because of the need to iterate through all the points in the polygon and having to constantly access a balanced tree data structure, the complexity for this step is: n * log n, so O(n log n). 
			</p>
			<p align="justify">
				After this step, we proceed to triangulate each of the polygons that have been created. This is done by sweeping across the polygon from the vertex with the lowest value of x to that with the highest. Since we already have a list of sorted vertices from step 1, we can use the same here. As we sweep across, we check for visibility between vertices and attach them if required while checking to make sure we do not intersect any other diagonals. This happens in a manner suitable for the creation of convex fans in our polygon. The more the number of vertices in the opposite side a particular vertex can ‘see’, the more the diagonals that will be drawn to it. This will come in handy later when we 3-colour our graph since the vertex of the convex fan will remain a single colour and simplify colouring for us. Reflex chains are also identified in this manner and diagonal added. By the end, the algorithm has proceeded through each of the monotone polygons and triangulated them all. Each diagonal can be created in constant time for the purposes of our algorithm. And since each triangulation requires the creation of (n-3) polygons, where n is the number of vertices in each monotone polygon, the overall complexity of this step is: O(n).
			</p>
			<br>
			<p align="center">
				In the figures below, the vertices marked in red act as convex fans. They are a meeting point for several diagonals drawn between vertices in the figure.
			</p>
			<br>
			<p align="center">
				<img src="images/ConvexFans.png" alt="Convex Fans Illustration">
			</p>
			<br>
			<p align="justify">
				Thus, overall this algorithm has a complexity of: O(n log n). The major portion of it is dominated by the monotone subdivision step.
			</p>
			<p align="justify">
				Some pseudocode which will give more clarity about our approach:
				<br>
				<br>
				Algorithm for <font face="consolas">monotonize(P):<br><br>
				<b>Input</b>: A simple polygon P stored as a list of vertices D.<br>
				<b>Output</b>: A partitioning of P into monotone sub-polygons, stored in another list E. <br>
				&emsp; 1. Construct a priority queue-like structure Q using the vertices of P, using their y-coordinates as priority. If two points have the same y-coordinate, then select the one with the smaller x-coordinate to have higher priority. <br>
				&emsp; 2. Initialize an empty binary search tree T. <br>
				&emsp; 3. While Q is not empty. <br>
				&emsp; 4. Remove the vertex with the highest priority from Q. <br>
				&emsp; 5. Handle the vertex, based on its type. <br><br>

				&emsp; If it is a start vertex, <br>
				&emsp; &emsp; 1. Insert it into T. <br>

				&emsp; Else If it is an end vertex,<br>
				&emsp; &emsp; 1. Check if the there is an unmatched merge vertex.<br>
				&emsp; &emsp; 2. If so, then add a diagonal between the end vertex and the merge vertex.<br>

				&emsp; Else if it is a split vertex,<br>
				&emsp; &emsp; 1. Search in T to find the closest vertex before it that is also visible to it. <br>
				&emsp; &emsp; 2. Once found, add a diagonal between the two vertices.<br>

				&emsp; Else if it is a merge vertex,<br>
				&emsp; &emsp; 1.  Remember the merge vertex. Add it to a stack so that it can be popped out when it eventually gets connected to another vertex later on using a diagonal.<br>

				&emsp; Else (it is a regular vertex),<br>
				&emsp; &emsp; 1. Add it to T in the required position.<br>
				</font>
				<br>
				<br>

				Algorithm for <font face="consolas">triangulateMonotonePolygons(P):<br><br>
				<b>Input</b>: A y-monotone polygon P stored in a list D. <br>
				<b>Output</b>: A triangulation of P stored in a list E. <br>
				&emsp; 1. Iterate across the polygons from left to right.<br>
				&emsp; 2. Initialize a stack , and continuously push vertices into it based on whether they are in the upper or lower chain.<br>
				&emsp; 3. On each iteration: <br>
				&emsp; 4. If vertex 1 and vertex 2 are on different chains, <br>
				&emsp; 5. Then Pop all the  vertices from S. <br>
				&emsp; 6. And then Insert a diagonal from the vertex to each popped vertex, other than the last vertex,<br>
				&emsp; 7. Else Pop one vertex from S. <br>
				&emsp; 8. Pop the other vertices from S as long as the diagonals lie inside P. Insert these diagonals into D. Push the last vertex that has been popped back onto S. This will complete the process for that polygon.<br>
				</font>
			</p>
			<br>
			<p align="justify">
				Figures showing results are below. For each of the figures, the red line segments represent the sides of the art gallery polygon, the green line segments represent the triangulations generated by our algorithm, the yellow, cyan and dark blue vertices are the results of our 3-colouring and the colour with the crosses represent the positions of the guards. Several of the figures have been scaled down in order to fit them into the report but the images can be viewed separately if desired.
			</p>
			<br>
			<br>
			<p align="center">1) This is a figure with 150 vertices. The light blue coloured vertices with the crosses in them are the guards.</p>
			<p align="center">
				<img src="images/Triangulation150Vertices.png" alt="Polygon with 150 vertices">
			</p>
			<br>
			<br>
			<p align="center">2) This is a figure with 200 vertices. The dark blue vertices show the positions of guards in this structure.</p>
			<p align="center">
				<img src="images/Triangulation200Vertices.png" alt="Polygon with 200 vertices">
			</p>
			<br>
			<br>
			<p align="center">3) This is a figure with 400 vertices. The yellow coloured vertices with the crosses denote the guards.</p>
			<p align="center">
				<img src="images/Triangulation400Vertices.png" alt="Polygon with 400 vertices">
			</p>
			<br>
			<br>
			<p align="center">4) This is a von koch figure with 500 vertices. The yellow vertices are the guards.</p>
			<p align="center">
				<img src="images/Triangulation500VonKochPolygon.png" alt="Von Koch Polygon">
			</p>
			<br>
			<br>
			<p align="center">5) This is a polygon representing the interior of the St.Sernin Cathedral in Toulouse, France. The dark blue vertices represent the guards.</p>
			<p align="center">
				<img src="images/TriangulationStSerninCathedral.png" alt="Real World Cathedral">
			</p>
			<br>
			<br>
			<p align="center">6) This is a simple polygon with 5 vertex guards shown in cyan.</p>
			<p align="center">
				<img src="images/TriangulationLessVertices.png" alt="Polygon with 150 vertices">
			</p>
			<br>
			<br>
		</section>
		<br>
		<section>
			<H3 align="center">Approach 2: Augmenting using Reflex Vertices</H3>
			<p align="justify">
				In any convex polygon, it is evident that one guard will be enough to guard it, as all points within the polygon are visible from all other points within it. If there is only one reflex vertex, all the points are still visible from the reflex vertex. This led us to believe, that the type of vertex has a pivotal role in deciding minimum guard points. O’Rourke has proved that placing guard at all reflex vertices is sufficient to cover a given art gallery polygon, but it is not always guaranteed to give a better solution than the existing n/3 lower bound. Justin Iwerks et al. have summarized lower bound for guards in terms of reflex and convex vertices.
			</p>
			<p align="center">
				<img src="images/ReflexVertices1.PNG" alt="Reflex Vertex Examples">
			</p>
			<br>
			<p>
				Guards at reflex vertices, better than existing ⌊n/3⌋ lower bound if  r ≤ ⌊c/2⌋ <br>
				r = reflex vertices, c = convex vertices, r + c = n <br>
				Number of sufficient guards = 1	   &emsp;&emsp;&nbsp; If r = 0 <br>
				&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;= r	   &emsp;&emsp;&nbsp;&nbsp;&nbsp;If r ≤ ⌊c/2⌋ <br>
				&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;= ⌊n/3⌋ &nbsp;&nbsp;&nbsp;  If ⌊c/2⌋ <  r  < 5c−12 <br>
				&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;= 2c-4 	&emsp; If r  ≥  5c-12 <br>
			</p>
			<p align="justify">
				These lower bound conditions can be used to determine if three coloring method is giving better solution. reflex vertices in a polygon can be identified in O(n) time, using determinant method.  
			</p>
			<p align="center">
				<img src="images/ReflexVertices2.PNG" alt="Reflex Vertex Examples2">
			</p>
			<p align="justify">
				As we can see in above polygon, both approaches do not yield minimum vertex solution, but are sufficient for art gallery coverage problem. More importantly, if  r ≤ ⌊c/2⌋, we can find equivalent or more optimal solution than 3 coloring approach in O(n) time.
			</p>
		</section>
		<br>
		<section>
			<H3 align="center">Approach 3: Augmenting using Visbility Polygons and Overlaps</H3>
			<p align="justify">
				Since approaches one and two alone don’t guarantee an optimal solution, we turned to the problem of visibility, i.e., calculating the vision of a guard given a set of polygons in a scene. Visibility polygons are a common method to represent the field of visibility of a given point in space. In 2D space, the area enclosed by the visibility polygon would represent all the points on the plane visible to that point. Visibility polygons are commonly used to model visibility in robotics as well as video games so they seemed like a good approach to take in our project.
			</p>
			<p align="justify">
				Naive algorithms to calculate visibility polygons involved uniformly casting rays from the selected point in all possible directions. Clearly, casting rays in all directions from 0 to 359 degrees would have been overkill for an algorithm, not to mention the problems with precision we would have encountered if we attempted to do so. Popularly, this is implemented by casting the rays with at intervals but this can often lead to small obstacles being overlooked. Moreover, his solution may have been theoretically simple to implement but computationally impractical. So we decided to go with a more plausible approach: casting rays to each of the vertices of the objects in the scene. This way, we can clearly figure out which objects are occluded and also, the cost is not too much.
			</p>
			<p align="justify">
				Our implementation knows at all times the locations vertices of the polygons contained within it. So we cast rays to each of them. In order to do so, we start by scanning for vertices from 0 degrees, or a line parallel to the x-axis and then go around till we reach the x-axis again. Each time we encounter a vertex, we add it to our visibility polygon. If another vertex occurs at the same angle with respect to the point but further away, we determine that a portion of the object is occluded and carry on. After we have completed the entire circular scan, we stitch together the visibility polygon and fill in the area of the polygon to clearly denote its extent. Implemented this way, the algorithm takes O(n2) time since we need to check intersections with all n points in the polygon which is an operation on its own. 
			</p>
			<p align="justify">
				Instead of just sticking with this approach, we decided to augment it further by storing the object in a balanced tree structure based on angle with respect to the point, and then by distance, so that looking them up would be a constant time operation for any point. Building up the tree takes O(n) time for each guard location being checked. If the guard is dragged around in the interactive application we made, each drag coordinate will regenerate the tree. This could help augment our previous implementation by potentially acting as an index - if that guard location is checked again, we can just use the previously generated treat to create the visibility polygon quickly. 
			</p>
			<p align="justify">
				Some pseudocode which will give more clarity about our approach:
				<br>
				<br>
				Algorithm for <font face="consolas">vertexRayCast(point, Scene):<br><br>
				<b>Inputs</b>: A point which signifies the position of the guard and the entire Scene in the form of a list of polygons. <br>
				<b>Output</b>: A visibility polygon. <br>
				VP = {}<br>
				for each polygon P in the Scene:<br>
				&emsp;for each vertex V of P:<br>
				&emsp;&emsp;d = The distance of V from point.<br>
				&emsp;&emsp;a = angle of V wrt point.<br>
				&emsp;&emsp;for each other polygon P2 in the Scene:<br>
				&emsp;&emsp;&emsp;d = minimum(d, The distance of P2 from point).<br>
				&emsp;&emsp;Add Vertex with angle a and distance d to VP.<br>
				return VP.</font>
			</p>
			<p align="justify">
				Figures showing our results are below:<br><br>
				For all the figures, the yellow circle represents a potential position for a guard, the grey region is outside the polygon, the black region is the unguarded portion inside the gallery, red coloured polygons are obstacles or ‘holes’ within the gallery and the yellow region is the visibility polygon generated for the guard and illustrates the line of sight. For our experiments, we have given the guards 360 degree unbounded vision which is obviously flawed in a real world scenario but suffices for experimental purposes.
			</p>
			<br>
			<p align="center">1) The figure below shows a block-like shaped polygon with obstacles inside.</p>
			<p align="center">
				<img src="images/ReportVisbilityBlockShaped.PNG" alt="Block Shaped Polygon">
			</p>
			<br>
			<br>
			<p align="center">2) The figure below shows a gallery with long, thin corridors.</p>
			<p align="center">
				<img src="images/ReportVisibilityCorridors.PNG" alt="Polygon with Corridors">
			</p>
			<br>
			<br>
			<p align="center">3) The figure below shows a gallery shaped roughly like an X.</p>
			<p align="center">
				<img src="images/ReportVisbilityXShaped.PNG" alt="X Shaped Polygon">
			</p>
			<br>
			<br>
			<p align="center">4) The figure below shows a gallery with a crown-like shape, a popular test case for art galleries.</p>
			<p align="center">
				<img src="images/ReportVisbilityReverseCrownShaped.PNG" alt="Reverse Crown Shaped Polygon">
			</p>
			<br>
			<br>
			<p align="center">5) The figures below show a gallery with an abnormal shape consisting of a star-like polygon and a pentagon connected with a narrow corridor.</p>
			<p align="center">
				<img src="images/ReportVisbilityWeird1.PNG" alt="Weird Polygon">
			</p>
			<p align="center">
				<img src="images/ReportVisbilityWeird2.PNG" alt="Weird Polygon2">
			</p>
			<p align="center">
				<img src="images/ReportVisbilityWeird3.PNG" alt="Weird Polygon3">
			</p>
			<br>
			<br>
			<p align="center">6) This is the overall scene with various configurations of guard(s) placed.</p>
			<p align="center">
				<img src="images/ReportVisbilityAll1.PNG" alt="Full Scene1">
			</p>
			<p align="center">
				<img src="images/ReportVisbilityAll1-2.PNG" alt="Full Scene2">
			</p>
			<p align="center">
				<img src="images/ReportVisbilityAll1-3.PNG" alt="Full Scene3">
			</p>
			<p align="center">
				<img src="images/ReportVisbilityAll3.PNG" alt="Full Scene with 3 Guards">
			</p>
			<p align="center">
				<img src="images/ReportVisbilityAll10.PNG" alt="Full Scene with 10 Guards">
			</p>
			<p align="center">
				<img src="images/ReportVisbilityAllSeveral.PNG" alt="Full Scene with a Large Number of Guards">
			</p>
			<br>
			<p align="justify">
				We also attempted to calculate and display the overlap between two visibility polygons. Unfortunately, the library we used to calculate the polygonal intersection turned out to be too slow for our interactive application. It would also slow down drastically if the overlapping area was too large. We were forced to test it only for cases where the overlaps were miniscule. The colour scheme for the results is similar to the above figures but with the added presence of a darker yellow portion outlined in white which represents the intersection polygon of the two guards’ visibility polygons. A few of our results are shown below:
			</p>
			<br>
			<p align="center">1) The figure below shows two guards inside a polygon that also contains an obstacle (in red). The two visibility polygons share a small corner of overlap.</p>
			<p  align="center">
				<img src="images/VisibilityOverlap.PNG" alt="Visibility Overlap">
			</p>
			<br>
			<br>
			<p align="center">2) The figure below shows two guards outside a polygon with a small quadrilateral overlap for their visibility.</p>
			<p  align="center">
				<img src="images/VisibilityOverlap2.PNG" alt="Visibility Overlap">
			</p>
			<br>
			<br>
			<p align="center">3) The figure below shows two more guards inside a polygon with an almost rhombus shaped overlap in their visibilities.</p>
			<p  align="center">
				<img src="images/VisibilityOverlap3.PNG" alt="Visibility Overlap">
			</p>
			<br>
			<br>
		</section>
		<br>
		<section>
			<H2 align="center">Shortcomings</H2>
			<p align="justify">
				As can be clearly seen, out approaches are not ideal. Traditionally, triangulation has been the bottleneck for all approaches used to solve the art gallery problem. Initially, the fastest algorithms to do them were O(n log n), which is what we have implemented. Implementing the O(n log log n) approach proved to time consuming and the best known O(n) method was deemed out of reach and convoluted for us. We chose to augment our approach using the reflex vertex approach. We believe this a nice way to segregate and quickly solve those polygons where the number of reflex vertices is less than or equal to half the number of convex ones and can lead to considerable speed ups for those particular cases. Still, if the condition does not hold, triangulation and colouring has to be done. And out approach to doing these are not optimal. The greedy colouring method we have utilized might not be ideal for large polygons. Also, partitioning large and complicated polygons into smaller, monotone polygons can become time consuming. Moreover, using 3-colouring alone for all polygons is not the best approach. This may work for normal polygons but does not produce good results for orthogonal ones. For those, 4-colouring followed by quadrilateralization is the recommended approach. Our solution can give minimal guard positions for some orthogonal polygons but not for all. Ideally, a more complicated technique would need to be employed that can identify the type of polygon being used and then choose an appropriate convex partitioning technique accordingly.
			</p>
			<p align="justify">
				Our reflex approach currently needs to iterate through all the vertices in the polygon to identify if triangulation is required. This could potentially increase computation time if the polygons being considered are gigantic.
			</p>
			<p align="justify">
				Our visibility approach can be used to minimize guards after 3-colouring has been done by checking for guards whose visibility polygons are proper subsets of others’, but this would require computing the overlaps between every possible combination of pairs of guards found earlier in the algorithm, which is again not a computationally simple task. Even if we just want to illustrate the overlaps between the visibility polygons of different sets of guards, the computation is not necessarily fast always. 
			</p>
			<p align="justify">
				Also, our method involves several small adjustments to fight the constant war against precision that commonly occurs in geometrical problems. To prevent weird computations from occurring, guards are always placed slightly to the left or right of a vertex leading to awkward results sometimes when the guard should be able to see both inside and outside the art gallery. Visually, this means interior visibility is always fine but exterior visibility is constrained to only one side of the polygon.
			</p>
			<p align="justify">
				Large scenes with several polygons could cause slow downs to polygon computation due to the number of rays needed to be cast for each guard. We tested our implementation with a maximum of 300 vertices totally and experienced not too much slow down but this is guaranteed to appear eventually. Also, adding too many guards to the scene can slow down the overall program since each guard would generate its own visibility polygon that would need to be changeable when dragged. 
			</p>
		</section>
		<br>
		<section>
			<H2 align="center">Challenges</H2>
			<p align="justify">
				The biggest challenge we faced throughout the project was the sheer amount of material available on the space. Since it is a well studied problem in computational geometry, several people have tried their hand at it. The literature is not always clear regarding which variant of the problem is being written about. Although we decided to concentrate on vertex guards for our approach, there were several papers with suggestions for edge guards, point guards and other variants. And wading through all this material was time consuming to say the least. Also, several papers tried to solve the same problems in very similar ways but with tiny tweaks built in. Since not all the papers talk in explicit terms about the algorithms they used - they tend to mention the approach in more roundabout ways - it took us a while to understand what these subtle differences were and internalize them. We also took a while to understand why different approaches might be required for polygons of different shapes. Initially we were trying to tackle all kinds of polygons with the same generic method. There are also results in the literature that have been derived using relationships between different variants of the art gallery problem. It took us a while to gather several of these and go through them to understand these connections and the conclusions arrived at because of them. Furthermore, several optimal proofs in the literature tend to be quite mathematically dense and convoluted. A stand out in this regard is the Chazelle paper that proves that polygon triangulation can actually be done in linear time. The approach described has been deemed impractical for real world applications because of the sheer amount of work required to achieve the result. Similarly, several of the papers that described the best run times turned out to be beyond our reach. Another constant challenge was dealing with precision in our approaches. We constantly had problem with zero division while finding slopes or determinants. We used epsilon to offset the error in most cases. But as discussed before, it does not necessarily give the best results always. We had to sacrifice some accuracy in order to get functional demos. Finally, as mentioned earlier, we found it hard to gather input polygons for our testing and even when we did find some, they were in different formats that would require pre-processing to be done in order to make them compatible with our code.
			</p>
		</section>
		<br>
		<section>
			<H2 align="center">Lessons Learned</H2>
			<p align="justify">
				Knowing what we know today, we would definitely have considered spending more time on the integer linear programming approaches we came across. We did go through the material and attempt to get a demo working but would have required much more time to achieve satisfactory results. 
			</p>
			<p align="justify">
				We would also try to look for ways to implement optimal polygon intersection algorithms that could viably work on top of our visibility implementation. We did not have time to implement our own so we ended up experimenting with third party libraries instead, which proved to suffer from their own issues as well as added significant computational cost to an already unideal method overall.
			</p>
			<p align="justify">
				Close to the end of our project, we discovered papers that took different approaches to finding the visibility for a point, some even mention approximate methods that lead to satisfactory results. Common methods mentioned were genetic algorithms and simulated annealing. We believe these methods could give interesting results that are worth looking into.
			</p>
			<p align="justify">
				We learned that investing in creating a random polygon generator early on during the project would have helped in rapid testing of our algorithms on different shapes. We thought we could find a library to do this readily but later failed to do so. This is something that would have greatly enhanced our speed and ability to run tests and generate results quickly.
			</p>
			<p align="justify">
				And finally, reducing our scope as much as possible early on might have helped. That would have led to us reading papers to do with the variants to the problem. The other side of the coin would be that we would not have found some of the important papers we stumbled upon later since it was our constant searching that unearthed papers that explained things in simpler terms as well as exposed us to different approaches.
			</p>
		</section>
		<br>
		<section>
			<H2 align="center">Possible Future Work</H2>
			<p align="justify">
				First thing to do would be to combine the visibility polygon approach with the triangulation and reflex approaches. Our triangulation and reflex approaches have been combined in a Python program but visibility currently functions entirely separately as a Javascript program. Since both were developed independently, we did not have the time to combine them yet. Combining them should not require to much effort, the process to generate visibility can directly be appended at the end of the triangulation and colouring process. In order to keep the application interactive, we recommend that Javascript be used for the final solution since interacting with the browser is much easier than having to deal with frameworks like Pygame for Python.
			</p>
			<p align="justify">
				If someone was to start our project today, we recommend that they look more closely into quadrilateralization as well as solution for identifiably orthogonal polygons. Popular approaches seem to be just as computationally expensive as triangulation but the approaches we tried turned out to be much more complicated than expected. There are also more complicated convex partitioning algorithms that attempt to partition polygons in a generic fashion which we did not have the time to look at more closely.
			</p>
			<p align="justify">
				A lot of the more modern methods to tackle the problem in an efficient manner seem to prefer approaching it as more of an optimization problem rather than one to do with geometry. They reduce it to a set cover space and then apply linear integer programming to solve it incrementally. Although we glanced at these methods, we did not attempt them as we chose the visibility approach instead.
			</p>
			<p align="justify">
				For the visibility problem, several methods use approximation techniques with local search variations like simulated annealing and steepest ascent to arrive at the maximum possible visibility polygon in an area within a polygon. Other popular approaches that can be attempted include more sophisticated space partitioning data structures like BSPs to make the visibility computation faster and cheaper.
			</p>
			<p align="justify">
				Our solution for visibility, can very easily be used as a viable component to solve the popular moving guards variant of the art gallery problem. The guards can be animated for a gallery, each movement will generate a new polygon whose overlap with others could be computed. And patrol paths can be arrived at for each guard so as to ensure every point in the gallery remains guarded at every point during the simulation. A machine learning algorithm to optimize for such a situation could be an interesting task. Reinforcement learning to arrive at the best paths seems like a good option. After several runs, the optimal path could be displayed.
			</p>
			<p align="justify">
				We never got to look at guards with visibility constraints. This would only need small tweaks to the algorithm described earlier. We would need to first set a limit for visibility for each guard. If a particular vertex in the scene is found to lie beyond the decided limit, a vertex of the visibility polygon lies exactly at that much distance from the guard. This would complicate guard positioning but make for an interesting exercise along with very different visuals.
			</p>
			<p align="justify">
				Finally, our visibility algorithm is also able to tackle visibility from points outside polygons as shown in some of the results above. This could be used to tackle the exterior visibility variant of the art gallery problem known as the fortress problem in the literature. Triangulation is known to be a viable approach here as well, albeit with the triangulations happening in a different manner instead of interior diagonals. We noticed some precision issues with our implementation that disallowed perfect vision both outside and inside the polygon when a guard is placed exactly at a vertex. The vision is always to one side on the exterior side, so many tweaks might be required if the exterior and interior visibility problem known as the prison yard problem were to be attempted with our technique.
			</p>
		</section>
		<br>
		<section>
			<H2 align="center">References</H2>
			<ol>
				<li>
					<cite>Joseph O'Rourke. <a href="http://cs.smith.edu/~jorourke/books/ArtGalleryTheorems/Art_Gallery_Full_Book.pdf">Art Gallery Theorems and Algorithms.</a></cite> (Possibly the best resource available for enthusiasts of problems in this domain).
				</li>
				<li>
					<cite>de Rezende P.J., de Souza C.C., Friedrichs S., Hemmer M., Kröller A., Tozoni D.C. (2016). <a href="https://arxiv.org/abs/1410.8720">Engineering Art Galleries</a>. In: Kliemann L., Sanders P. (eds) Algorithm Engineering. Lecture Notes in Computer Science, vol 9220. Springer, Cham. Engineering Art Galleries.</cite>
				</li>
				<li>
					<cite>Urrutia, Jorge. (2000). Art Gallery and Illumination Problems. Handbook of Computational Geometry. 10.1016/B978-044482537-7/50023-1. <a href="http://www.matem.unam.mx/urrutia/ArtBook.html/Completo.pdf">Art Gallery and Illumination Problems</a>.</cite>
				</li>
				<li>
					<cite>Lee, D & K. Lin, Arthur. (1986). <a href="https://dl.acm.org/citation.cfm?id=13657">Computational Complexity of Art Gallery Problems</a>. IEEE Transactions on Information Theory. 32. 276-282. 10.1109/TIT.1986.1057165.</cite>
				</li>
				<li>
					<cite>Hemanshu Kaul, IIT. <a href="http://www.math.iit.edu/~kaul/talks/LongArtGalleryTalk.pdf">The Art Gallery Problem</a>.</cite>
				</li>
				<li>
					<cite>Purdue University. <a href="https://www.cs.purdue.edu/homes/aliaga/cs635-10/lec-artgallery.pdf">Art Gallery Theorems and Algorithms</a>.</cite>
				</li>
				<li>
					<cite>Justin Iwerks, Joseph S. B. Mitchell. <a href="http://www.sciencedirect.com/science/article/pii/S0020019012001937">The art gallery theorem for simple polygons in terms of the number of reflex and convex vertices</a>.</cite>
				</li>
				<li>
					<cite>Red Blob Games. <a href="https://www.redblobgames.com/articles/visibility/">Visibility</a>.</cite>
				</li>
				<li>
					<cite>IIT Delhi. <a href="http://www.cse.iitd.ernet.in/~ssen/geomschool/nandy/Art-gallery-approximation.pdf">Approximation Algorithms for Art Gallery Problems</a>.</cite>
				</li>
				<li>
					<cite>Erik Krohn. <a href="http://www.uwosh.edu/faculty_staff/krohne/papers/comprehensive.pdf">Survey of Terrain Guarding and Art Gallery Problems</a>.</cite>
				</li>
				<li>
					<cite>Gorkem Safak. <a href="https://www.nada.kth.se/utbildning/grukth/exjobb/rapportlistor/2009/rapporter09/safak_gorkem_09126.pdf">The Art-Gallery Problem: A Survey and an Extension</a>.</cite>
				</li>
				<li>
					<cite>Oleksandr Goncharov. <a href="https://github.com/vrd/js-intersect">Javascript library for intersection of polygons</a>.</cite>
				</li>
				<li>
					<cite>Ernestus, M., Friedrichs, S., Hemmer, M. et al. J Glob Optim (2017) 68: 23. <a href="https://doi.org/10.1007/s10898-016-0452-2">Algorithms for Art Gallery Illumination</a>.</cite>
				</li>
				<li>
					<cite>Édouard Bonnet, Tillmann Miltzow. <a href="https://arxiv.org/abs/1607.05527">An Approximation Algorithm for the Art Gallery Problem</a>.</cite>
				</li>
				<li>
					<cite>Francisc Bungiu, Michael Hemmer, John Hershberger, Kan Huang, Alexander Kröller. <a href="https://arxiv.org/abs/1403.3905">Efficient Computation of Visibility Polygons</a>.</cite>
				</li>
				<li>
					<cite>Mahdi Moeini , Daniel Schermer , Oliver Wendt. <a href="http://roadef2017.event.univ-lorraine.fr/abstracts/ROADEF2017_paper_187.pdf"> Mobile Guards to Oversee an Art Gallery</a>.</cite>
				</li>
				<li>
					<cite>Pawel Zylinski. <a href="https://www.elibm.org/ft/960843">Orthogonal art galleries with holes: a coloring proof of Aggarwal’s Theorem</a>.</cite>
				</li>
				<li>
					<cite>Bernard Chazelle. <a href="https://www.cs.princeton.edu/~chazelle/pubs/polygon-triang.pdf">Triangulating a Simple Polygon in Linear Time</a>.</cite>
				</li>
				<li>
					<cite>Bajuelos, António & Canales, Santiago & Hernandez, Gregorio & Martins, Ana. (2008). <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.484.5649&rep=rep1&type=pdf">Optimizing the Minimum Vertex Guard Set on Simple Polygons via a Genetic Algorithm</a>.</cite>
				</li>
				<li>
					<cite>Computational Geometry - Algorithms and Applications. 3rd Edition.<a href=""></a></cite>
				</li>
				<li>
					<cite>Antonio Leslie Bajuelos Domínguez, Gregorio Hernández Peñalver, Santiago Canales Cano, Ana Mafalda Martins. <a href="http://sweet.ua.pt/leslie/Papers/MVGS_GNT.pdf">Minimum vertex guard problem for orthogonal polygons: a genetic approach</a>.</cite>
				</li>
				<li>
					<cite>Tomás A.P., Bajuelos A.L. (2004). <a href="https://link.springer.com/chapter/10.1007/978-3-540-25945-9_36">Generating Random Orthogonal Polygons</a>. In: Conejo R., Urretavizcaya M., Pérez-de-la-Cruz JL. (eds) Current Topics in Artificial Intelligence. Lecture Notes in Computer Science, vol 3040. Springer, Berlin, Heidelberg. </cite>
				</li>
				<li>
					<cite>Joseph O’Rourke, Mandira Virmani. <a href="http://cs.smith.edu/~jorourke/Papers/GenRandPoly.pdf">Generating Random Polygons</a>.</cite>
				</li>
				<li>
					<cite>Wikipedia. <a href="https://en.wikipedia.org/wiki/Art_gallery_problem">The Art Gallery Problem</a>.</cite>
				</li>
				<li>
					<cite>Wikipedia. <a href="https://en.wikipedia.org/wiki/Visibility_polygon">Visibility Polygon</a>.</cite>
				</li>
				<li>
					<cite>Art Gallery Problem Library, by M. C. Couto, P. J. de Rezende and C. C. de Souza. <a href="http://www.ic.unicamp.br/~cid/Problem-instances/Art-Gallery/AGPVG/index.html">AGPLIB</a>.</cite>
				</li>
				<li>
					<cite>Stackexchange. Picture of <a href="https://math.stackexchange.com/questions/249041/star-shaped-polygons">Convex fans</a>.</cite>
				</li>
				<li>
					<cite>Kumar Ghosh, Subir. (2010). <a href="http://www.sciencedirect.com/science/article/pii/S0166218X09004855">Approximation algorithms for art gallery problems in polygons</a>. Discrete Applied Mathematics. 158. 718-722. 10.1016/j.dam.2009.12.004. </cite>
				</li>
			</ol>
		</section>
		<br>
		<br>
		<hr>
		<hr>
		<hr>
		<br>
		<br>
		<section>
			<a name="visibilityApp" />
			<H2 align="center">Visibility Application</H2>
			<div align="center">
  				<canvas id="canvas" width="1500" height="700"></canvas>
  			</div>
		</section>
		<script>
  			var width = 1500;
			var height = 700;
			var dragIndex;
			var dragging;
			var numGuards = 2; //Change this and refresh the page to change the number of guards displayed randomly.
			var observerX = [];
			var observerY = [];
			var limit = 200;

			//Generate random guard positions.
			for(var i=0;i<numGuards;i++){
				observerX.push(randomIntFromInterval(10, width-30));
				observerY.push(randomIntFromInterval(10, height-30));
			}

			//Get canvas context.
			var canvas = document.getElementById('canvas');

			//Get random numbers between two numbers.
			function randomIntFromInterval(min,max)
			{
    			return Math.floor(Math.random()*(max-min+1)+min);
			}

			//Called when the mouse is moved.
			function mouseMoveListener(evt) {
				var posX;
				var posY;
				var shapeRad = 8;
				var minX = shapeRad;
				var maxX = canvas.width - shapeRad;
				var minY = shapeRad;
				var maxY = canvas.height - shapeRad;

				var bRect = canvas.getBoundingClientRect();

				//Adjust for the window.
				mouseX = (evt.clientX - bRect.left)*(canvas.width/bRect.width);
				mouseY = (evt.clientY - bRect.top)*(canvas.height/bRect.height);
				
				//Get accurate positions.
				posX = mouseX - dragHoldX;
				posX = (posX < minX) ? minX : ((posX > maxX) ? maxX : posX);
				posY = mouseY - dragHoldY;
				posY = (posY < minY) ? minY : ((posY > maxY) ? maxY : posY);

				//Set position of the guard accordingly.
				observerX[dragIndex] = posX;
				observerY[dragIndex] = posY;
				
				//Re-render scene.
				init();
			}

			//Compute the visibility polygon using the position of the guard and the polygons that are present in the scene.
			compute = function(position, segments) {
				var polygon = [];
			  
			  	//Sort the line segments of the polygons in a circular manner from the guard.
				var sorted = sortPoints(position, segments);
			  
				var map = new Array(segments.length);
				for (var i = 0; i < map.length; ++i) map[i] = -1;

				var heap = [];
				var start = [position[0] + 1, position[1]];

				//Enter into tree incrementally.
				for (var i = 0; i < segments.length; ++i) {
					var a1 = angle(segments[i][0], position);
					var a2 = angle(segments[i][1], position);
					var active = false;
					if (a1 > -180 && a1 <= 0 && a2 <= 180 && a2 >= 0 && a2 - a1 > 180) active = true;
					if (a2 > -180 && a2 <= 0 && a1 <= 180 && a1 >= 0 && a1 - a2 > 180) active = true;
					if (active) {
						insert(i, heap, position, segments, start, map);
					}
				}
			  
			  	//Enter into the visibility polygon based on angle and distance.
				for (var i = 0; i < sorted.length;) {
					var extend = false;
					var shorten = false;
					var orig = i;
					var vertex = segments[sorted[i][0]][sorted[i][1]];
					var old_segment = heap[0];
					do {
						if (map[sorted[i][0]] != -1) {
							if (sorted[i][0] == old_segment) {
								extend = true;
								vertex = segments[sorted[i][0]][sorted[i][1]];
							}
							remove(map[sorted[i][0]], heap, position, segments, vertex, map);
						} else {
							insert(sorted[i][0], heap, position, segments, vertex, map);
							if (heap[0] != old_segment) {
								shorten = true;
							}
						}
						++i;
						if (i == sorted.length) break;
					} while (sorted[i][2] < sorted[orig][2] + epsilon());

					if (extend) {
						polygon.push(vertex);
						var cur = intersectLines(segments[heap[0]][0], segments[heap[0]][1], position, vertex);
						if (!equal(cur, vertex)){
			        	polygon.push(cur);
			      		} 
					} else if (shorten) {
			      
						polygon.push(intersectLines(segments[old_segment][0], segments[old_segment][1], position, vertex));
			      
						polygon.push(intersectLines(segments[heap[0]][0], segments[heap[0]][1], position, vertex));
					} 
				}
			  
			  	//Return the polygon.
				return polygon;
			};

			//Convert the polygons int line segments.
			convertToSegments = function(polygons) {
				var segments = [];
				for (var i = 0; i < polygons.length; ++i) {
					for (var j = 0; j < polygons[i].length; ++j) {
						var k = j+1;
						if (k == polygons[i].length) k = 0;
						segments.push([polygons[i][j], polygons[i][k]]);
					}
				}
				return segments;
			};

			//Retrieve the chosen value of epsilon for resolving precision issues.
			epsilon = function() {
				return 0.0000001;
			};

			//Check if the two points are equal.
			equal = function(a, b) {
				if (Math.abs(a[0] - b[0]) < epsilon() && Math.abs(a[1] - b[1]) < epsilon()) return true;
				return false;
			};

			//Remove a pint form the tree.
			remove = function(index, heap, position, segments, destination, map) {
				map[heap[index]] = -1;
				if (index == heap.length - 1) {
					heap.pop();
					return;
				}
				heap[index] = heap.pop();
				map[heap[index]] = index;
				var cur = index;
				var parent = findParent(cur);
				if (cur != 0 && lessThan(heap[cur], heap[parent], position, segments, destination)) {
					while (cur > 0) {
						var parent = findParent(cur);
						if (!lessThan(heap[cur], heap[parent], position, segments, destination)) {
							break;
						}
						map[heap[parent]] = cur;
						map[heap[cur]] = parent;
						var temp = heap[cur];
						heap[cur] = heap[parent];
						heap[parent] = temp;
						cur = parent;
					}
				} else {
					while (true) {
						var left = child(cur);
						var right = left + 1;
						if (left < heap.length && lessThan(heap[left], heap[cur], position, segments, destination) &&
								(right == heap.length || lessThan(heap[left], heap[right], position, segments, destination))) {
							map[heap[left]] = cur;
							map[heap[cur]] = left;
							var temp = heap[left];
							heap[left] = heap[cur];
							heap[cur] = temp;
							cur = left;
						} else if (right < heap.length && lessThan(heap[right], heap[cur], position, segments, destination)) {
							map[heap[right]] = cur;
							map[heap[cur]] = right;
							var temp = heap[right];
							heap[right] = heap[cur];
							heap[cur] = temp;
							cur = right;
						} else break;
					}
				}
			};

			//Insert into the tree.
			insert = function(index, heap, position, segments, destination, map) {
				var intersect = intersectLines(segments[index][0], segments[index][1], position, destination);

				if (intersect.length == 0) return;

				var cur = heap.length;
				heap.push(index);
				map[index] = cur;

				while (cur > 0) {
					var parent = findParent(cur);
					if (!lessThan(heap[cur], heap[parent], position, segments, destination)) {
						break;
					}
					map[heap[parent]] = cur;
					map[heap[cur]] = parent;
					var temp = heap[cur];
					heap[cur] = heap[parent];
					heap[parent] = temp;
					cur = parent;
				}
			};

			//Check if a point is lesser than another based on the angle and distance.
			lessThan = function(index1, index2, position, segments, destination) {
				var inter1 = intersectLines(segments[index1][0], segments[index1][1], position, destination);
				var inter2 = intersectLines(segments[index2][0], segments[index2][1], position, destination);

				if (!equal(inter1, inter2)) {
					var d1 = distance(inter1, position);
					var d2 = distance(inter2, position);
					return d1 < d2;
				}

				var end1 = 0;
				if (equal(inter1, segments[index1][0])) end1 = 1;

				var end2 = 0;
				if (equal(inter2, segments[index2][0])) end2 = 1;

				var a1 = angle2(segments[index1][end1], inter1, position);
				var a2 = angle2(segments[index2][end2], inter2, position);

				if (a1 < 180) {
					if (a2 > 180) return true;
					return a2 < a1;
				}

				return a1 < a2;
			};

			//Get the parent from the tree based on the index.
			findParent = function(index) {
				return Math.floor((index-1)/2);
			};

			//Get the child from the tree based on the index.
			child = function(index) {
				return 2*index+1;
			};

			//Calculate the angle based on 3 points with adjustment.
			angle2 = function(a, b, c) {
				var a1 = angle(a,b);
				var a2 = angle(b,c);
				var a3 = a1 - a2;

				if (a3 < 0) a3 += 360;
				if (a3 > 360) a3 -= 360;

				return a3;
			};

			//Sort points based on their distances and coordinates.
			sortPoints = function(position, segments) {
				var points = new Array(segments.length * 2);
				for (var i = 0; i < segments.length; ++i) {
					for (var j = 0; j < 2; ++j) {
						var a = angle(segments[i][j], position);
						points[2*i+j] = [i, j, a];
					}
				}
			  
				points.sort(function(a,b) {return a[2]-b[2];});
			  
				return points;
			};

			//Get angle with positive X-axis.
			angle = function(a, b) {
				return Math.atan2(b[1]-a[1], b[0]-a[0]) * 180 / Math.PI;
			};

			//Check the intersection.
			intersectLines = function(a1, a2, b1, b2) {
				var ua_t = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);
				var ub_t = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);
				var u_b  = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);

				if (u_b != 0) {
					var ua = ua_t / u_b;
					var ub = ub_t / u_b;
					return [a1[0] - ua * (a1[0] - a2[0]), a1[1] - ua * (a1[1] - a2[1])];
				}

				return [];
			};

			//Get the distance.
			distance = function(a, b) {
				return (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]);
			};

			//Check if points are present on the line segment.
			isOnSegment = function(xi, yi, xj, yj, xk, yk) {
			  return (xi <= xk || xj <= xk) && (xk <= xi || xk <= xj) &&
			         (yi <= yk || yj <= yk) && (yk <= yi || yk <= yj);
			};

			//Compute the direction of the ray.
			computeDirection = function(xi, yi, xj, yj, xk, yk) {
			  a = (xk - xi) * (yj - yi);
			  b = (xj - xi) * (yk - yi);

			  return a < b ? -1 : a > b ? 1 : 0;
			};

			//CHeck if the line segments intersect.
			doLineSegmentsIntersect = function(x1, y1, x2, y2, x3, y3, x4, y4) {
			  d1 = computeDirection(x3, y3, x4, y4, x1, y1);
			  d2 = computeDirection(x3, y3, x4, y4, x2, y2);
			  d3 = computeDirection(x1, y1, x2, y2, x3, y3);
			  d4 = computeDirection(x1, y1, x2, y2, x4, y4);

			  return (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&
			          ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) ||
			         (d1 == 0 && isOnSegment(x3, y3, x4, y4, x1, y1)) ||
			         (d2 == 0 && isOnSegment(x3, y3, x4, y4, x2, y2)) ||
			         (d3 == 0 && isOnSegment(x1, y1, x2, y2, x3, y3)) ||
			         (d4 == 0 && isOnSegment(x1, y1, x2, y2, x4, y4));
			};

			//Re-render for each frame.
			window.requestAnimFrame = (function() {
				return  window.requestAnimationFrame       || 
					window.webkitRequestAnimationFrame || 
					window.mozRequestAnimationFrame    || 
					window.oRequestAnimationFrame      || 
					window.msRequestAnimationFrame     || 
					function(callback, element){
						window.setTimeout(callback, 1000 / 60);
					};
			})();

			//Execute when a mouse click is detected.
			function onDocumentMouseClick(event){
			  
			  var rect = canvas.getBoundingClientRect();
			  
			  observer_x = event.clientX - rect.left;
			  observer_y = event.clientY - rect.top;

			  //Re-render the scene.
			  init();
			}

			//Checks if a guard has been clicked on.
			function hitTest(x, y, mx, my) {
		
				var dx;
				var dy;

				dx = mx - x;
				dy = my - y;
						
				return (dx*dx + dy*dy < 20);
			}

			//Executed when the mouse button is down.
			function mouseDownListener(evt){

				var i;
				var highestIndex = -1;
				var bRect = canvas.getBoundingClientRect();

				//Check coordinates.
				mouseX = (evt.clientX - bRect.left);
				mouseY = (evt.clientY - bRect.top);
						
				//Check if any of the guards have been clicked on.
				for (i=0; i < numGuards; i++) {
					if	(hitTest(observerX[i], observerY[i], mouseX, mouseY)) {
						dragging = true;
						if (i > highestIndex) {
							dragIndex = i;
							dragHoldX = mouseX - observerX[i];
							dragHoldY = mouseY - observerY[i];
							highestIndex = i;
							dragIndex = i;
						}
					}
				}
				
				//Check if a drag event has occurred and initiate movement accordingly.
				if (dragging) {
					window.addEventListener("mousemove", mouseMoveListener, false);
				}

				//Add listeners for mouse down and mouse up events.
				canvas.removeEventListener("mousedown", mouseDownListener, false);
				window.addEventListener("mouseup", mouseUpListener, false);
				
				if (evt.preventDefault) {
					evt.preventDefault();
				} 
				else if (evt.returnValue) {
					evt.returnValue = false;
				} 
				return false;
			}

			//Executed when a drag event has ended.
			function mouseUpListener(evt) {
				canvas.addEventListener("mousedown", mouseDownListener, false);
				window.removeEventListener("mouseup", mouseUpListener, false);

				if (dragging) {
					dragging = false;
					window.removeEventListener("mousemove", mouseMoveListener, false);
				}
			}

			//Re-render the scene.
			function init() {
				
				var changed = true;
				var polygons = [];
				var segments = [];
				var polygon = [];
				
			  	canvas.addEventListener("mousedown", mouseDownListener, false);
				setup();
				requestAnimFrame(update);

				//Setup all the polygons.
				function setup() {
					polygons.push([[-1,-1],[width+1,-1],[width+1,height+1],[-1,height+1]]); //Bounding box.
			    
			    	polygons.push([[520,320],[520,230],[565,230],[580,245],[610,245],[640,230],[700,230],[715,260],[640,260],[640,290],[685,290],[685,320],[610,320],[580,275],[550,320]]); //X-shaped.
					
			    	polygons.push([[200, 200], [220, 200], [220, 180], [140, 180], [140, 160], [160, 160], [160, 140], [60, 140], [60, 120], [160, 120], [160, 20], [180, 20], [180, 160], [220, 160], [220, 140], [240, 140], [240, 160], [260, 160], [260, 120], [280, 120], [280, 160], [300, 160], [300, 140], [320, 140], [320, 160], [360, 160], [360, 180], [240, 180], [240, 200], [260, 200], [260, 220], [240, 220], [240, 240], [380, 240], [380, 260], [360, 260], [360, 280], [380, 280], [380, 300], [360, 300], [360, 320], [340, 320], [340, 260], [320, 260], [320, 320], [300, 320], [300, 260], [280, 260], [280, 380], [260, 380], [260, 360], [220, 360], [220, 340], [260, 340], [260, 260], [240, 260], [240, 320], [220, 320], [220, 300], [200, 300], [200, 440], [180, 440], [180, 420], [160, 420], [160, 460], [140, 460], [140, 420], [120, 420], [120, 560], [100, 560], [100, 540], [60, 540], [60, 520], [100, 520], [100, 420], [40, 420], [40, 400], [180, 400], [180, 300], [160, 300], [160, 360], [140, 360], [140, 300], [100, 300], [100, 280], [120, 280], [120, 260], [20, 260], [20, 240], [120, 240], [120, 200], [140, 200], [140, 280], [220, 280], [220, 260], [180, 260], [180, 240], [220, 240], [220, 220], [200, 220]]); //Long, dark corridors.

			    	polygons.push([[1012, 8], [1060, 54], [1023, 140], [1050, 106], [1199, 76], [1161, 69], [1180, 34], [1186, 58], [1191, 32], [1222, 88], [1210, 100], [1216, 159], [1275, 161], [1285, 91], [1236, 78], [1226, 83], [1186, 7], [1146, 72], [1111, 75]]); //Weird shape with a star.

			    	//polygons.push([[820, 220], [820, 430], [930, 430], [930, 460], [820, 460], [820, 640], [890, 640], [890, 710], [1000, 710], [1000, 530], [960, 530], [960, 500], [1000, 500], [1000, 430], [1030, 430], [1030, 500], [1070, 500], [1070, 530], [1030, 530], [1030, 710], [1180, 710], [1180, 670], [1210, 670], [1210, 710], [1310, 710], [1310, 530], [1210, 530], [1210, 570], [1180, 570], [1180, 500], [1310, 500], [1310, 320], [1180, 320], [1180, 290], [1310, 290], [1310, 220], [960, 220], [960, 290], [1100, 290], [1100, 320], [930, 320], [930, 220]]); //Blocky building.

			    	polygons.push([[560, 34], [575, 200], [600, 100], [625, 200], [650, 100], [675, 200], [700, 100], [725, 200], [750, 100], [775, 200], [800, 100], [825, 200], [850, 100], [875, 200], [900, 100], [925, 200], [950, 34]]); //Crown.

			    	//polygons.push([[990.0, 1000.0], [990.0, 990.0], [970.0, 990.0], [970.0, 860.0], [860.0, 860.0], [860.0, 880.0], [910.0, 880.0], [910.0, 890.0], [950.0, 890.0], [950.0, 980.0], [740.0, 980.0], [740.0, 780.0], [700.0, 780.0], [700.0, 620.0], [690.0, 620.0], [690.0, 950.0], [680.0, 950.0], [680.0, 680.0], [550.0, 680.0], [550.0, 940.0], [540.0, 940.0], [540.0, 670.0], [630.0, 670.0], [630.0, 660.0], [510.0, 660.0], [510.0, 560.0], [490.0, 560.0], [490.0, 570.0], [480.0, 570.0], [480.0, 650.0], [470.0, 650.0], [470.0, 810.0], [460.0, 810.0], [460.0, 870.0], [350.0, 870.0], [350.0, 900.0], [270.0, 900.0], [270.0, 770.0], [250.0, 770.0], [250.0, 760.0], [320.0, 760.0], [320.0, 740.0], [390.0, 740.0], [390.0, 730.0], [430.0, 730.0], [430.0, 600.0], [300.0, 600.0], [300.0, 610.0], [110.0, 610.0], [110.0, 640.0], [130.0, 640.0], [130.0, 700.0], [240.0, 700.0], [240.0, 790.0], [100.0, 790.0], [100.0, 750.0], [60.0, 750.0], [60.0, 800.0], [90.0, 800.0], [90.0, 840.0], [40.0, 840.0], [40.0, 830.0], [50.0, 830.0], [50.0, 720.0], [70.0, 720.0], [70.0, 580.0], [200.0, 580.0], [200.0, 510.0], [210.0, 510.0], [210.0, 490.0], [500.0, 490.0], [500.0, 500.0], [520.0, 500.0], [520.0, 520.0], [340.0, 520.0], [340.0, 540.0], [290.0, 540.0], [290.0, 550.0], [560.0, 550.0], [560.0, 590.0], [570.0, 590.0], [570.0, 630.0], [660.0, 630.0], [660.0, 530.0], [620.0, 530.0], [620.0, 270.0], [610.0, 270.0], [610.0, 200.0], [600.0, 200.0], [600.0, 120.0], [590.0, 120.0], [590.0, 110.0], [440.0, 110.0], [440.0, 140.0], [450.0, 140.0], [450.0, 190.0], [380.0, 190.0], [380.0, 290.0], [370.0, 290.0], [370.0, 320.0], [280.0, 320.0], [280.0, 310.0], [220.0, 310.0], [220.0, 300.0], [190.0, 300.0], [190.0, 370.0], [180.0, 370.0], [180.0, 280.0], [160.0, 280.0], [160.0, 430.0], [150.0, 430.0], [150.0, 450.0], [140.0, 450.0], [140.0, 380.0], [30.0, 380.0], [30.0, 460.0], [20.0, 460.0], [20.0, 440.0], [10.0, 440.0], [10.0, 330.0], [80.0, 330.0], [80.0, 260.0], [120.0, 260.0], [120.0, 230.0], [170.0, 230.0], [170.0, 210.0], [230.0, 210.0], [230.0, 250.0], [260.0, 250.0], [260.0, 240.0], [310.0, 240.0], [310.0, 30.0], [360.0, 30.0], [360.0, 20.0], [400.0, 20.0], [400.0, 10.0], [420.0, 10.0], [420.0, 60.0], [410.0, 60.0], [410.0, 90.0], [330.0, 90.0], [330.0, 100.0], [730.0, 100.0], [730.0, 130.0], [770.0, 130.0], [770.0, 340.0], [820.0, 340.0], [820.0, 80.0], [580.0, 80.0], [580.0, 50.0], [530.0, 50.0], [530.0, 40.0], [650.0, 40.0], [650.0, 70.0], [840.0, 70.0], [840.0, 180.0], [850.0, 180.0], [850.0, 350.0], [870.0, 350.0], [870.0, 220.0], [920.0, 220.0], [920.0, 150.0], [960.0, 150.0], [960.0, 170.0], [940.0, 170.0], [940.0, 400.0], [900.0, 400.0], [900.0, 420.0], [890.0, 420.0], [890.0, 470.0], [800.0, 470.0], [800.0, 390.0], [710.0, 390.0], [710.0, 360.0], [720.0, 360.0], [720.0, 160.0], [670.0, 160.0], [670.0, 410.0], [640.0, 410.0], [640.0, 480.0], [760.0, 480.0], [760.0, 690.0], [780.0, 690.0], [780.0, 920.0], [750.0, 920.0], [750.0, 970.0], [930.0, 970.0], [930.0, 930.0], [810.0, 930.0], [810.0, 910.0], [830.0, 910.0], [830.0, 820.0], [790.0, 820.0], [790.0, 710.0], [880.0, 710.0], [880.0, 850.0], [980.0, 850.0], [980.0, 960.0], [1000.0, 960.0], [1000.0, 1000.0]]);
			    	polygons.push([[1145, 390], [1258, 384], [1258, 452], [1120, 445]]); //Hole inside blocky building.
			    	polygons.push([[868, 270], [917, 266], [920, 377], [868, 362]]); //Hole2 inside blocky building.
			    
			    	//Convert them all to line segments.
					segments = convertToSegments(polygons);
				};

				//Called to update the scene for each frame.
				function update() {
					if (changed) {
						var canvas = document.getElementById('canvas');
						var ctx = canvas.getContext("2d");
						ctx.clearRect(0, 0, width, height);
						ctx.beginPath();
						ctx.rect(0, 0, width, height);
						ctx.fillStyle = '#666';
						ctx.fill();

						draw(ctx);
						changed = false;
					}
					requestAnimFrame(update);
				};

				//Draw all the polygons and obstacles present in the scene along with the guards and the visibility polygons.
				function draw(ctx) {
			    	var polys = [];
			    	for(var i=0;i<numGuards;i++){
			    		polys.push(compute([observerX[i], observerY[i]], segments));
			    	}

					for (var i = 1; i < polygons.length; ++i) {
						ctx.beginPath();
						ctx.moveTo(polygons[i][0][0], polygons[i][0][1]);
						for (var j = 1; j < polygons[i].length; ++j) {
							ctx.lineTo(polygons[i][j][0], polygons[i][j][1]);
						}

						//Colour the galleries.
			      		ctx.fillStyle = "black";

			      		//Colour the obstacles differently
			      		if(i == polygons.length-1 || i == polygons.length-2){
			      			ctx.fillStyle = "brown";
			      		}

						ctx.fill();
					}

					for(var i=0;i<numGuards;i++){
						ctx.beginPath();
						ctx.moveTo(polys[i][0][0], polys[i][0][1]);
						for (var j = 1; j < polys[i].length; ++j) {
							ctx.lineTo(polys[i][j][0], polys[i][j][1]);
						}
			    		ctx.fillStyle = "#ffff66";
						ctx.fill();
					}

			    	ctx.fillStyle = "#ffff66";
					ctx.fill();

					for (var i = 0; i < segments.length; ++i) {
						ctx.beginPath();
						ctx.moveTo(segments[i][0][0], segments[i][0][1]);
						ctx.lineTo(segments[i][1][0], segments[i][1][1]);
						ctx.strokeStyle = "black";
						ctx.lineWidth = 2;
						ctx.stroke();
					}

					//Create the guards.
					for(var i=0;i<numGuards;i++){
						ctx.beginPath();
						ctx.arc(observerX[i], observerY[i], 8, 0, Math.PI*2, true);
						ctx.fillStyle = "yellow";
						ctx.fill();
						ctx.strokeStyle = "black";
						ctx.stroke();						
					}
				};
			};
  		</script>
	</body>
</html>

